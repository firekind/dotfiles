#!/usr/bin/env python3

import os
import sys
import json
import shutil
from typing import List, Dict, Callable
import subprocess
import argparse

# Global variables
config: Dict[str, str] = {}
_preinstall: List = []
_postinstall: List = []
_core: List = []

# argparser
parser = argparse.ArgumentParser("./install")
parser.add_argument(
    "--config", type=str, default="config.json", help="config file path"
)
args = parser.parse_args()

# helper decorators
#
def preinstall(func: Callable):
    _preinstall.append(func)
    return func


def postinstall(func: Callable):
    _postinstall.append(func)
    return func


def core(tag: str = None):
    def decorator(func):
        if tag == None or tag == args.wm:
            _core.append(func)
        return func

    return decorator


# stuff to do before installing
#

@preinstall
def backup():
    try:
        os.mkdir(config["backup_dir"])
    except FileExistsError:
        print("backup directory exists!", file=sys.stderr)
        sys.exit(-1)

    for _, paths_to_backup in config["backup"].items():
        for path in paths_to_backup:
            path = os.path.expanduser(path)

            if os.path.exists(path):
                shutil.move(path, config["backup_dir"])


# actual installation
#
@core()
def install_ppas():
    for ppa in config["ppa"]:
        execute_command("sudo add-apt-repository %s" % ppa)

    for cmd in config["post-ppa-commands"]:
        execute_command(cmd)

    execute_command("sudo apt update")


@core()
def uninstall_stuff():
    packages = []

    for pkg in config["uninstall"]:
        if pkg.startswith("grep:"):
            res = execute_command("apt list --installed | grep %s" % pkg.split(":", 1)[-1])
            packages.extend(
                [i[:i.index("/")].strip() for i in res.split("\n")]
            )
        else:
            packages.append(pkg)

    execute_command("sudo apt purge %s" % " ".join(packages))
    execute_command("sudo apt purge --autoremove")


@core()
def install_stuff():
    install_packages(config["install"])


@core()
def install_dotfiles():
    dots = config["dotfiles"]["base"] + config["dotfiles"][args.wm]
    execute_command("stow -t %s %s" % (os.path.expanduser("~"), " ".join(dots)))


# stuff to do after installation
#
@postinstall
def run_commands():
    for cmd in config["post-install"]:
        execute_command(cmd)

@postinstall
def print_messages():
    print(
        'Note: To get QT5 themes working properly, first set the theme using kvantum. Then, run qt5ct and set\n'
        '* Appearance -> Style = kvantum\n'
        '* Font = Cantarell 10\n'
        '* Icon Theme = Papirus-Adapta-Nokto-Maia\n'
        'Then, add export QT_QPA_PLATFORMTHEME="qt5ct" to .profile and reboot (or logout)'
    )


# utility functions
#
def install_packages(packages: List[str]):
    command_str = (
        "sudo apt install %s"
        % " ".join(packages)
    )
    res = execute_command(command_str)

    if res.returncode != 0:
        print("error running command %s\nError: %s", command_str, res.stderr)
        sys.exit(-1)


def load_config():
    global config
    with open(args.config, "r") as f:
        config = json.load(f)


def execute_command(
    command: str, suppress_output: bool = False
) -> subprocess.CompletedProcess:

    if command.count("|") > 0 or command.count(">") > 0:
        return _execute_piped_command(command)
    else:
        if suppress_output:
            return subprocess.run(
                command.split(), stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL
            )
        return subprocess.run(command.split())


def _execute_piped_command(command: str):
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    res, _ = p.communicate()

    return res

# main function
#
def main():
    load_config()
    func_list = _preinstall + _core + _postinstall

    for func in func_list:
        func()


if __name__ == "__main__":
    main()
