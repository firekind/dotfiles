#!/usr/bin/env python3

import os
import sys
import json
import shutil
from typing import List, Dict, Callable
import subprocess
import argparse

# Global variables
config: Dict[str, str] = {}
_preinstall: List = []
_postinstall: List = []
_core: List = []

# argparser
parser = argparse.ArgumentParser("./install")
parser.add_argument(
    "--config", type=str, default="config.json", help="config file path"
)
args = parser.parse_args()

# helper decorators
#
def preinstall(func: Callable):
    _preinstall.append(func)
    return func


def postinstall(func: Callable):
    _postinstall.append(func)
    return func


def core(tag: str = None):
    def decorator(func):
        if tag == None or tag == args.wm:
            _core.append(func)
        return func

    return decorator


# stuff to do before installing
#

@preinstall
def backup():
    try:
        os.mkdir(config["backup_dir"])
    except FileExistsError:
        print("backup directory exists!", file=sys.stderr)
        sys.exit(-1)

    for _, paths_to_backup in config["backup"].items():
        for path in paths_to_backup:
            path = os.path.expanduser(path)

            if os.path.exists(path):
                shutil.move(path, config["backup_dir"])


# actual installation
#
@core()
def install_ppas():
    for ppa in config["ppa"]:
        execute_command("sudo add-apt-repository %s" % ppa)

    for cmd in config["post-ppa-commands"]:
        execute_command(cmd)

    execute_command("sudo apt update")


@core()
def uninstall_stuff():
    packages = []

    for pkg in config["uninstall"]:
        if pkg.startswith("grep:"):
            res = execute_command("apt list --installed | grep %s" % pkg.split(":", 1)[-1])
            packages.extend(
                [i[:i.index("/")].strip() for i in res.split("\n") if i != ""]
            )
        else:
            packages.append(pkg)

    execute_command("sudo apt purge %s" % " ".join(packages))
    execute_command("sudo apt purge --autoremove")


@core()
def install_stuff():
    install_packages(config["install"])


@core()
def install_dotfiles():
    dots = config["dotfiles"]
    execute_command("stow -t %s %s" % (os.path.expanduser("~"), " ".join(dots)))


# stuff to do after installation
#
@postinstall
def run_commands():
    for cmd in config["post-install"]:
        execute_command(cmd)

@postinstall
def append_profile():
    with open(os.path.expanduser("~/.profile"), "a") as f:
        f.write('export PATH=$PATH:/opt/ghc/bin')

@postinstall
def print_messages():
    print(
        """
Note: To get QT5 themes working properly, first set the theme using kvantum. Then, run qt5ct and set
* Appearance -> Style = kvantum
* Font = Cantarell 10
* Icon Theme = Papirus-Adapta-Nokto-Maia
Then, add export QT_QPA_PLATFORMTHEME="qt5ct" to .profile and reboot (or logout).

to install xmonad, xmobar and xmonad-contrib, run
$ echo "PATH=$PATH:/opt/ghc/bin" > ~/.profile
$ sudo -i
# PATH = $PATH:/opt/ghc/bin
# cabal update
# cabal v1-install --global xmonad-0.15 xmonad-contrib-0.16
# cabal v1-install --global xmobar-0.37 --flags="all_extensions"

also, add a file called xmonad.desktop to /usr/share/xsessions containing the following content:

[Desktop Entry]
Type=Application
Name=Xmonad
Comment=Lightweight X11 tiled window manager written in Haskell
Exec=xmonad
Icon=xmonad
Terminal=false
StartupNotify=false
Categories=Application;

to install starship prompt, run
$ curl -fsSL https://starship.rs/install.sh | bash
"""
    )


# utility functions
#
def install_packages(packages: List[str]):
    command_str = (
        "sudo apt install %s"
        % " ".join(packages)
    )
    res = execute_command(command_str)

    if res.returncode != 0:
        print("error running command %s\nError: %s", command_str, res.stderr)
        sys.exit(-1)


def load_config():
    global config
    with open(args.config, "r") as f:
        config = json.load(f)


def execute_command(
    command: str, suppress_output: bool = False
) -> subprocess.CompletedProcess:

    pipe_count = command.count("|")
    if pipe_count == 0:
        if suppress_output:
            return subprocess.run(
                command.split(), stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL
            )
        return subprocess.run(command.split())

    elif pipe_count == 1:
        return _execute_piped_command(command)

    else:
        raise Exception("commands with more than one pipe not supported.")

def _execute_piped_command(command: str):
    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    res, _ = p.communicate()

    return res.decode("ascii")

# main function
#
def main():
    load_config()
    func_list = _preinstall + _core + _postinstall

    for func in func_list:
        func()


if __name__ == "__main__":
    main()
